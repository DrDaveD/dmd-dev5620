.\" 
.\"									
.\"	Copyright (c) 1987,1988,1989,1990,1991,1992   AT&T		
.\"			All Rights Reserved				
.\"									
.\"	  THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T.		
.\"	    The copyright notice above does not evidence any		
.\"	   actual or intended publication of such source code.		
.\"									
.\" 
.ds ZZ APPLICATION DEVELOPMENT PACKAGE
.TH DMDEBUG 1
.SH NAME
dmdebug \- symbolic debugger
.SH SYNOPSIS
.B dmdebug
[\fB\-u\fR file] [\fB\-m\fR layersys]
[\f3\-t\fR dmdebug.m ]
[\f3\-l\fR 32ld ]
.SH DESCRIPTION
.I Dmdebug
is a source-level symbolic debugger for C programs running under
.IR layers .
Running asynchronously and
communicating by means of the keyboard and mouse in its
own layer, it provides for controlled execution of another process running under
.IR layers .
It takes advantage of the
source symbol tables generated by 
the
.BR \-g " option"
of
.IR dmdcc .
.PP
The options are:
.TP 15
\f3\-u \f2file\f1
used to specify a user program symbol tables.
.TP
\f3\-m\f2 layersys\f1
to specify alternate layersys symbol tables.
.TP
\f3\-t \f2dmdebug.m\f1
used to specify alternate
.I dmdebug
downloaded portion.
.TP
\f3\-l \f2loader\f1
used to specify an alternate loader to download
.IR dmdebug.m .
.SH MODEL
Most commands manipulate and are interpreted with respect to three
major values:
.IP
i) \fIstate\fR: the state of the debugged process
.IP
ii) \fIcurrent context\fR: the active statement in one of the functions on the call stack
.IP
iii) \fIcurrent location\fR: an arbitrary address within DMD memory.
.LP
If there is a state, it is displayed in a status line at the top of
.IR dmdebug 's
layer; otherwise an appropriate message appears there.
.PP
The subject state variable may have one of the following values:
.IP
RUNNING
.IP
HALTED
.IP
BREAKPOINT_TRAPPED
.bp
.IP
SINGLE_STEP_TRAPPED
.IP
EXCEPTION_TRAPPED
.PP
The RUNNING state and the various TRAPPED states have obvious interpretation.
A process is HALTED
when a flag is set in its process descriptor to prevent
layersys
from scheduling it to run.
If there is a current context, the last item on the button 3 menu
is '\fIfunc_id\fR() vars', where \fIfunc_id\fR is the function.
If the current location is non-zero, it appears as the normal command prompt. 
.SH INTERACTION
Apart from the status line (which video inverts momentarily whenever
its contents change),
.IR dmdebug 's
layer scrolls conventionally.
.PP
The
.I dmdebug
utility
usually prompts ':' (or '\fIaddress\fR:' with the current location)
when it is ready to accept a command entered from either the keyboard or
a mouse menu.
If a 'dead mouse' icon replaces the cursor, the mouse may not be used.
This happens only when prompting for the symbol table file.
The 'menu' icon that replaces the cursor shows when there are menus available
on buttons 2 and/or 3.
It is always safe to raise a menu. If it is not what you want, do not select
anything and there is no harm done.
When
.I dmdebug
is busy for a long period,
a 'coffee cup' icon replaces the cursor.
.PP
If invoked with 
.BR "\-m"","
\fIdmdebug\fR uses the specified \fIfile\fR to obtain symbol table information
for \fIlayers\fR itself (the system standard is default). The
.B \-u 
flag specifies a source for symbols for the layer being debugged (see
.I layer
below).
.SH MOUSE
Buttons 2 and 3 display command menus.
Button 3 commands treat the process only at the source language level.
Button 2 commands allow further access to the terminal's raw memory.
Some commands call for confirmation by a second button hit on a 'skull' cursor.
.SH MENUS
Selecting nothing from a menu is always safe; it has no effect.
Selecting 'more...' at the top or bottom of a menu, moves to another portion of
a menu which is too large to be displayed.
Menus too large to fit into the fixed structures in the terminal are broken
into segments that will fit, with a special item at the top and/or bottom
to move to the adjoining segments:
The standard menu primitive in the terminal process was modified to scroll
quickly through menus that are too large to be popped up,
using a ``scroll bar'' beside the menu to control which 12 items are visible.
Menus are broken into segments of 64 items,
which can be scrolled with 12 items visible at any one time.
.SH Button 3
.TP 15
.B layer
Selects a new layer for examination.
The layer is identified by
hitting the layer with the 'bullseye' cursor.
The layer is flashed by video invert.
There is then a prompt for an object file with \-g symbol tables.
Response is a file name, or null (carriage return) to select the default as shown,
or '\-' to proceed without symbols.
The default file name is usually taken from the
.I 32ld
command which loaded the layer.
It is therefore best to give an
.I absolute
path name when using
.I 32ld
and
.I jx
in shell scripts and programs.
This default may be changed at the time of
.I dmdebug
invocation by using the \fB\-u\fR command line argument.
.TP
.B quit
Must be confirmed.
.TP
.B breakpts
Repeatedly offers a further menu on button 3 with the commands
.B list [\fIn\fB], clear all,
and a list of functions in the program.
If no breakpoints are currently set the list and clear entries
are replaced by an entry indication '<none set>'.
The value in brackets with
.B list
shows how many breakpoints are currently set.
The commands list and clear them all, respectively.
.B Clear all
must be confirmed.
Selecting a function identifier offers a terminal menu with:
.sp
.ce
.B call
.ce
.B return
.ce
.B both
.ce
.B none
.sp
One of these is tagged by '>', indicating what breakpoints are set.
Selecting one modifies the breakpoints on the function. 
The breakpoint at function call is
.I after
the stack frame has been advanced,
but
.I before
initialization of the registers and automatics.
The breakpoint on function return is
.I after
the return value has been set, but
.I before
the stack frame is retracted.
It is safe to set and clear breakpoints
.I while the process is running.
To set breakpoints before the program starts, use the \-z option
on
.I 32ld
to leave the process halted after loading.
Breakpoints can only be set on individual C statements or physical locations by means
of the keyboard (below).
.TP
.B globals
Repeatedly offers a menu with the program's globals.
Each one selected is displayed.
.TP
.B stmt step
Executes a single statement of the program.
After it is executed the status line shows the next statement to be
executed.
It does not set the current context, however;
\fBfunction\fR or \fBtraceback\fR must be used explicitly before
local variables are accessible.
Statement stepping can only be used after stopping on breakpoint.
It is not available when the process is merely suspended by \fBhalt\fR.
.TP
.B go
Resumes execution of the process.
.TP
.B halt
Suspends execution of the process.
.TP
.B traceback
Lists the active function stack frames from the one that
is executing back to main().
Each line in the traceback has the form:
.sp
.ce
\fIfile\fR:\fIline\fR[+\fIoffset\fR] in \fIfunction(arg, ... arg)\fR
.sp
giving the statement being executed as source file, line number
(and instruction byte offset) within a function and its arguments.
The deepest stack frame becomes the current context.
.TP
.B function
Offers a menu of functions (in traceback order) from which one may be selected
as current context.
.bp
.TP
.I func_id\fB() vars
Repeatedly offers a menu of the local variables, arguments and statics 
which are alive at the active statement in the current stack frame.
Each variable is classified as 'lcl' (local), 'reg' (register), 'sta'
(static) or 'arg' (argument).
.SH EXPRESSION EVALUATION
.PP
.I Dmdebug
recognizes and evaluates a subset of C expressions that includes fixed point
arithmetic, subscripting, indirection, field selection, assignment and function
application.
Expressions may be entered from the keyboard.
In fact, most expressions evaluated are those of a further subset that are
built from menu-driven interaction.
Pointers and aggregate variables can be used as the basis for building
expressions, in which the user is repeatedly offered menus of applicable
operators and functions.
This begins with the the selection of a variable from a menu, say of the
variables in a function with an argument,
\fIpt\fR,
and a local variable,
\fIi\fR :
.sp
.TS
center;
l l.
pt	arg
\f3i	lcl\f1
.TE
.sp
Suppose \fBpt\fR is selected, a pointer to a record of type \fBPoint\fR :
.sp
.RS 5
.nf
.ft CM
struct     Point {
     short     x;
     short     y;
};
struct     Point     *pt;
.ft R
.fi
.RE
.sp
.sp
The expression is evaluated.
Its type determines which operators are applicable and they are presented as
a menu of expressions, in which the expression-in-hand,
\fBPoint\fR, is represented by a tilde:
.sp
.ce 3
\(ap[?]
\(ap->x
`->y
.sp
Selecting \fB\(ap->x\fR or \fB\(ap->y\fR
causes the function to be re-invoked recursively with the expression \fBpt->x\fR
or \fBpt->y\fR, respectively.
Both of these are the simple case where the expression evaluates to a scalar; 
the value is printed and the function returns to the level above, where the
same menu is presented again.
Selecting \fB\(ap[?]\fR
produces a scrolling menu of subscripts (with a somewhat arbitrary range of
-4..128):
.sp
.ce 14
\-4
\-3
\-2
\-1
0
1
2
3
4
5
6
\&.
\&.
\&.
.sp
Selecting one of these subscripts re-invokes the function with a new expression
like \fBpt[2]\fR,
in which case the expression is a record, not a pointer, and the selections
in the next menu are:
.ce 2
\(ap.x
\(ap.y
.sp
where the tilde now represents \fBpt[2]\fR .
.PP
In fact, the menu above also contains special entries which are not
normal expressions:
.sp
.ce 4
Point{\(ap}
   \(ap.x
   \(ap.y
\f2%point(\(ap)\f1
.sp
\fBPoint{\(ap}\fR prints the whole record, say:
.DS
{x=226,y=413}
.DE
\fB%point(\(ap)\fR
calls a graphics function in the terminal to display a cross-hair at that point on
the screen.
\fB%point(\(ap)\fR
is included in the menu because \f2dmdebug\f1 knows that struct Point
is one of the primitive graphics data structures defined for all DMD programs.
Other functions display \fBRectangle\fRs, \fBTexture\fRs, \fBTexture16\fRs
and \fBBitmap\fRs.
``Off-screen'' bitmaps are a good example;
the programmer can see the effects of graphics operations on images as they
are constructed, before they are copied to the region of memory that is mapped
to the display.
.PP
This general mechanism supports chasing through arrays and through arbitrary
linked data structures.
In addition to the built-in operations at each step, monadic functions in the
program, whose argument is the type of the expression-in-hand, are sought from
the symbol table and included in the menu.
Again, it is the responsibility of the user know when it is safe to invoke
a function.
.SH Pointer Chasing
.PP
If a variable selected from the global or local menu is a structure,
a pointer to a structure or an array, it is displayed as one of:
.sp
.TS
center;
l l.
\fIvariable\fR .	<field>
\fIvariable\fR \->	<field>
\fIvariable\fR	<index>
.TE
.sp
respectively.
The menu on button 3 can then be used to complete the expression and
display its value.
While the expression this yields is still an aggregate,
a further selection must be made to extend it.
Making no selection or hitting button 1 or 2 'backs up' out of an 
expression.
.SH Button 2
.PP
Button 2 has commands which root around in memory displaying it as bytes, shorts
(16 bits), long words (32 bits), structures, unions, and enumerations.
Before using this, the command
.sp
.ce 1
 . \fIexpression\fR
.sp
is needed to set the current location to the value of the expression.
.PP
The model for this button is that the menu itself is a window into memory.
Selections from the menu change the location, size, and format of the objects
seen the next time it is raised and can
copy useful ones into the scrolling area.
.PP 
The top three menu items are the location and
value for the current memory location (tagged by '.')
and its two neighbors.
Selecting one of these three writes it into the scrolling
area and makes that location the current one.
.PP
Selecting \fBbyte, short, \fRor \fBlong\fR fixes the size of objects viewed.
Selecting \fBdecimal, octal, hex, \fRor \fBascii\fR fixes the radix.
The ascii radix displays each byte as a C character
constant (e.g., 'a', '\\n', '\\277').
.PP
For pointer chasing, if the object size is \fBlong\fR and
the value at the current location makes sense as an address,
the location referenced and its value are shown (tagged by '*'.)
It can be picked to become the current location.
.PP
\fBString\fR shows the zero-terminated strings starting at the current location,
and at current\-4 and current +4.
Long strings are truncated.
.PP
\fBStruct\fR and \fBenum\fR present menus of the structures and enumerations
in the program.
Selecting one interprets memory as a vector of such objects.
Most structures are horribly truncated in the menu, but are displayed in full
when selected and displayed in the scrolling area.
.PP
If there is a symbolic form for the current location it is displayed as
an item tagged by '.'.
Selecting this gives a fuller symbolic form.
.PP
A final item may appear in this menu.
If
.I dmdebug
is unable to display an object when given its symbolic name, it saves
the address and places it in the menu.
It may be picked to become the current location.
.SH KEYBOARD
.I Dmdebug
repeatedly prompts with the address of the
current memory location and accepts one or more of the
following commands separated by semi-colons.
Constants may be unsigned decimal, octal, or
hexadecimal, in C notation.
.TP 18
.B .la
Select a new layer to debug.
.TP
.B .exit
Exits.
.TP
.B \^^D
Exits.
.TP
.B \fIexpression\fR
Evaluate and print its value.
The following operators are supported:
.ce 2
+ \- * / %  \->  [ ] . = (binary)
& * \-            (unary)
Functions may also be called, but are executed by
.IR dmdebug 's
process (while the user's is suspended if necessary.)
Structures may be expressed as \fIstruct_id(expr, ... expr)\fR,
for example, Point(100,200).
Identifiers are bound to variables as they they would be in the current
context using C's scope rules.
.TP
.B .v
Print all local variables visible from the current context.
.TP
.B .t
Display a function traceback. It sets the current context
to the deepest user function. 
.TP
.B .h
Halt the process.
.TP
.B .g
Go the process.
.TP
.B .?
Display the current state of the debugged process.
.TP
.B .bc \fIfunction_id\fR
Set a breakpoint at function call.
.TP
.B .br \fIfunction_id\fR
Set a breakpoint at function return.
.TP
.B .bs \fIfile line_no\fR
Set a breakpoint at a given line within a source file.
.TP
.B .cc \fIfunction_id\fR
Clear breakpoint at function call.
.TP
.B .cr \fIfunction_id\fR
Clear breakpoint at function return.
.TP
.B .cs \fIfile line_no\fR
Clear breakpoint at a given line within a source file.
.TP
.B .bl
List all breakpoints.
.TP
.B .ca
Clear all breakpoints.
.TP
.B .c [\fIcount\fR]
Set the new current context to the function which the present one calls.
When given, iterate the number of times specified by the constant.
This and the following command are used in conjunction with the main menu
entry \fIfunction\fR, which permits one to examine previous stack frames
in the call sequence.
.TP
.B .r [\fIcount\fR]
Set the new current context to the function to which the present one returns.
When given, iterate the number of times specified by the constant.
.TP
.B . \fIexpression\fR
Set the address of current memory location to the value of the expression.
.TP
.if n .B [+|-] \fI[offset\fR]
.if t .B [\(+-] [\fIoffset\fR]
Set the current location relative to itself by the given constant times
the size of the object last displayed.
The null command (a carriage return) is equivalent to +1.
.TP
.B .x
Find a symbolic name for the current memory location.
.TP
.B .b
The current location is displayed as
a byte.
.TP
.B .sh
The current location is displayed as a short.
.TP
.B .l
The current location is displayed as a long.
.TP
.B \fIstructure_id\fR
The name of a defined structure
displays memory from the current location as an instance of the structure.
This also works for unions and enumerations.
.TP
.B %\fIregister\fR
Set the current location to where the specified register
in the current context was saved and display as a long (32 bits).
\fIRegister\fR is r[0\-8], sp, fp, ap, psw, sp, pcbp, isp, and pc.
.TP
.B \(**
Set the address of the current location to the 32 bit address
at the current location.
.TP
.B .li \fIfile line_no\fR
Display the first instruction of code generated for
the statement beginning at a line number of a source file.
.TP
.B .= \fIexpression\fR
Write value of expression to the current memory location.
Operand length is that of the
previous .b, .sh, or .l command (or button 2 equivalent).
.TP
.B < \fIfile\fR
Read command script from a file.
.TP
.B .bi
Set breakpoint on the instruction at the current memory location.
.TP
.B .ci
Clear breakpoint on the instruction at the current memory location
.TP
.B .si [\fIcount\fR]
Single step the next instruction or number of instructions.
This command can only be invoked if the layer being debugged
is stopped at a breakpoint or prior single step.
.TP
.B .ss [\fIcount\fR]
Single step the next C statement or number of statements.
This command can only be invoked if the layer being debugged
is stopped at a breakpoint or prior single step.
.TP
.B .\fIbase\fR
Set radix for display of addresses, where \fIbase\fR is 8, 10, or 16.
.TP
.B .cd [\fIdirectory\fR]
Change directory.
.TP
.B .pwd
Print the current directory.
.TP
.B .sd \fIdirectory\fR
Adds
.I directory
to the list of directories to search for source files.
.TP
.B .zP
Sets the current location to the address of the debugged process's
process control block.
.TP
.B .zd \fIaddr duration\fR
Displays the terminals raw memory on the screen for the given duration.
.SH SEE ALSO
dmdcc(1), layers(1), 32ld(1).
.br
sdb(1) in the
\f2\s-1UNIX\s+1 System V User Reference Manual\f1.
.SH DIAGNOSTICS
The diagnostics produced by
.I dmdebug
are intended to be self-explanatory.
Messages prefaced by '5620: ' are generated and printed autonomously by
the terminal program when the state of the debugged process is not as expected.
They appear in exceptional situations where it is hard for
.I dmdebug
to keep track of events.
Examples are: manually patching
breakpoint traps, arbitrary stores into code or control memory,
reloading of the debugged layer.
Once such a diagnostic is given, there are no guarantees.
.SH BUGS
The
.I dmdebug
program
is still evolving and has some rough edges.
The .= command can write anywhere in memory.
Anonymous structures, unions and enumerations are not supported.
For example:
.sp
.ce
.ft CM
typedef { int field } Record;
.ft R
.sp
introduces an anonymous structure.
A simple remedy is to name the structure thus:
.sp
.ce
.ft CM
typedef Record { int field } Record;
.ft R
